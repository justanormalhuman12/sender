{"entries":[{"timestamp":1759765470080,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":18,"diffs":[[1,""]]},{"start1":1,"length1":3118,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":112,"length1":129,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":229,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1759765845506,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":19,"length1":19,"diffs":[[1,"const LOOP_MS = 50           // slightly slower updates for smoothness\n"]]},{"start1":153,"length1":23,"diffs":[[1,"const TURN_POWER = 200\n"]]},{"start1":197,"length1":45,"diffs":[[1,"const RATE_LIMIT = 60        // slower ramping for smoothness\nconst SMOOTH_COUNT = 5       // running average count\n"]]},{"start1":778,"length1":35,"diffs":[[1,"// running average to smooth tilt\n"]]},{"start1":1903,"length1":92,"diffs":[[1,"        let turnFactor = Math.min(Math.abs(baseSpeed) / MAX_SPEED, 1)\n"]]},{"start1":2004,"length1":43,"diffs":[[1,"            // gentle turn while moving\n"]]},{"start1":2397,"length1":0,"diffs":[[1,"\n        if (turnSign > 0) basic.showArrow(ArrowNames.East)\n        else basic.showArrow(ArrowNames.West)\n    } else {\n        // show direction\n        if (baseSpeed > 30) basic.showArrow(ArrowNames.North)\n        else if (baseSpeed < -30) basic.showArrow(ArrowNames.South)\n        else basic.clearScreen()\n"]]},{"start1":2712,"length1":22,"diffs":[[1,"    // smooth motor speed changes\n"]]},{"start1":2987,"length1":33,"diffs":[[1,""]]},{"start1":3023,"length1":103,"diffs":[[1,"        radio.sendString(leftTarget.toString() + \",\" + rightTarget.toString())\n"]]}]}]},{"timestamp":1759766084158,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":101,"length1":0,"diffs":[[1,"const TURN_POWER = 180\n"]]},{"start1":167,"length1":0,"diffs":[[1,"const SMOOTH_COUNT = 5\n"]]},{"start1":273,"length1":0,"diffs":[[1,"let tiltHistory: number[] = []\n"]]},{"start1":655,"length1":0,"diffs":[[1,"// running average for smooth tilt\nfunction smoothTilt(raw: number): number {\n    tiltHistory.push(raw)\n    if (tiltHistory.length > SMOOTH_COUNT) tiltHistory.shift()\n    let sum = 0\n    for (let v of tiltHistory) sum += v\n    return sum / tiltHistory.length\n}\n\n"]]},{"start1":1003,"length1":27,"diffs":[[1,"    let forwardRaw = -smoothTilt(rawY)\n"]]},{"start1":1103,"length1":22,"diffs":[[1,""]]},{"start1":1270,"length1":68,"diffs":[[1,"        if (forwardRaw > 0) baseSpeed = -baseSpeed\n"]]},{"start1":1531,"length1":21,"diffs":[[1,"    // A+B = STOP\n"]]},{"start1":1781,"length1":70,"diffs":[[1,"        let turnFactor = Math.min(Math.abs(baseSpeed) / MAX_SPEED, 1)  // gentle turn scale\n"]]},{"start1":1904,"length1":0,"diffs":[[1,"            // smooth turning while moving\n"]]},{"start1":2194,"length1":102,"diffs":[[1,"            leftTarget = -turnSign * TURN_POWER\n            rightTarget = turnSign * TURN_POWER\n"]]},{"start1":2329,"length1":125,"diffs":[[1,"    leftTarget = rateLimit(prevLeft, clamp(leftTarget, -MAX_SPEED, MAX_SPEED), RATE_LIMIT)\n    rightTarget = rateLimit(prevRight, clamp(rightTarget, -MAX_SPEED, MAX_SPEED), RATE_LIMIT)\n"]]},{"start1":2570,"length1":0,"diffs":[[1,"    // send only if not A+B stop\n"]]},{"start1":2639,"length1":79,"diffs":[[1,"        radio.sendString(Math.round(leftTarget).toString() + \",\" + Math.round(rightTarget).toString())\n"]]}]}]},{"timestamp":1759766533546,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":62,"diffs":[[1,""]]},{"start1":19,"length1":52,"diffs":[[1,"const LOOP_MS = 50\n"]]},{"start1":59,"length1":57,"diffs":[[1,"const MAX_SPEED = 255\n"]]},{"start1":101,"length1":22,"diffs":[[1,"const TURN_MIX = 100\nconst RATE_LIMIT = 60\n"]]},{"start1":145,"length1":195,"diffs":[[1,""]]},{"start1":192,"length1":22,"diffs":[[1,""]]},{"start1":227,"length1":12,"diffs":[[1,""]]},{"start1":228,"length1":163,"diffs":[[1,""]]},{"start1":606,"length1":1052,"diffs":[[1,""]]},{"start1":691,"length1":285,"diffs":[[1,""]]},{"start1":729,"length1":0,"diffs":[[1,"    let baseSpeed = 0\n\n    // check deadzone\n"]]},{"start1":893,"length1":52,"diffs":[[1,""]]},{"start1":941,"length1":199,"diffs":[[1,"        if (forwardRaw > 0) baseSpeed = -baseSpeed // backward tilt\n"]]},{"start1":1051,"length1":131,"diffs":[[1,""]]},{"start1":1115,"length1":44,"diffs":[[1,"    let turnLeft = input.buttonIsPressed(Button.A)\n    let turnRight = input.buttonIsPressed(Button.B)\n\n    // hard stop A+B\n    if (turnLeft && turnRight) {\n"]]},{"start1":1320,"length1":132,"diffs":[[1,"        radio.sendString(\"STOP\")\n        basic.showIcon(IconNames.No)\n    } else if (turnLeft || turnRight) {\n        let turnSign = turnRight ? 1 : -1\n        let turnFactor = Math.min(Math.abs(baseSpeed) / MAX_SPEED, 1)\n\n"]]},{"start1":1573,"length1":119,"diffs":[[1,"            leftTarget = clamp(baseSpeed - turnSign * TURN_MIX * turnFactor, -MAX_SPEED, MAX_SPEED)\n            rightTarget = clamp(baseSpeed + turnSign * TURN_MIX * turnFactor, -MAX_SPEED, MAX_SPEED)\n"]]},{"start1":1791,"length1":96,"diffs":[[1,"            // spin in place\n            leftTarget = -turnSign * MAX_SPEED / 2\n            rightTarget = turnSign * MAX_SPEED / 2\n"]]},{"start1":1939,"length1":168,"diffs":[[1,"    // smooth ramping\n"]]},{"start1":2087,"length1":178,"diffs":[[1,""]]},{"start1":2142,"length1":140,"diffs":[[1,"    if (!(turnLeft && turnRight)) {\n        radio.sendString(leftTarget.toString() + \",\" + rightTarget.toString())\n    }\n"]]}]}]},{"timestamp":1759767383190,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"// Sender: tilt-to-drive controller (no LEDs/visual feedback)\n"]]},{"start1":154,"length1":22,"diffs":[[1,"const MAX_SPEED_NORMAL = 230\nconst MAX_SPEED_SPORT = 255\n"]]},{"start1":253,"length1":0,"diffs":[[1,"\nconst SMOOTH_FACTOR_NORMAL = 3\nconst SMOOTH_FACTOR_SPORT = 2\nconst RATE_LIMIT_NORMAL = 80\nconst RATE_LIMIT_SPORT = 160\n\n"]]},{"start1":405,"length1":0,"diffs":[[1,"const SPORT_TOGGLE_HOLD_MS = 1200\n"]]},{"start1":496,"length1":0,"diffs":[[1,"let sportMode = false\n"]]},{"start1":675,"length1":0,"diffs":[[1,"let bToggleFlag = false\n"]]},{"start1":857,"length1":0,"diffs":[[1,"function rateLimit(prev: number, target: number, maxDelta: number): number {\n    let delta = target - prev\n    if (delta > maxDelta) delta = maxDelta\n    if (delta < -maxDelta) delta = -maxDelta\n    return prev + delta\n}\n\n"]]},{"start1":1230,"length1":43,"diffs":[[1,"    // A+B long press -> calibrate neutral (non-visual)\n"]]},{"start1":1343,"length1":0,"diffs":[[1,"            // start of simultaneous press\n"]]},{"start1":1481,"length1":172,"diffs":[[1,"        } else {\n            if (!abCalibratedFlag && now - aDownStart >= CALIBRATE_HOLD_MS) {\n                neutralY = input.acceleration(Dimension.Y)\n                abCalibratedFlag = true\n            }\n"]]},{"start1":1706,"length1":0,"diffs":[[1,"    // B long press -> toggle sport mode (non-visual)\n    if (b && !a) {\n        if (!bWasDown) {\n            bDownStart = now\n            bToggleFlag = false\n        } else {\n            if (!bToggleFlag && now - bDownStart >= SPORT_TOGGLE_HOLD_MS) {\n                sportMode = !sportMode\n                bToggleFlag = true\n            }\n        }\n    }\n\n    // update last button states\n"]]},{"start1":2131,"length1":17,"diffs":[[1,"    // read and center tilt\n"]]},{"start1":2245,"length1":0,"diffs":[[1,"    // mode params\n    let MAX_SPEED = sportMode ? MAX_SPEED_SPORT : MAX_SPEED_NORMAL\n    let SMOOTH_FACTOR = sportMode ? SMOOTH_FACTOR_SPORT : SMOOTH_FACTOR_NORMAL\n    let RATE_LIMIT = sportMode ? RATE_LIMIT_SPORT : RATE_LIMIT_NORMAL\n\n"]]},{"start1":2686,"length1":0,"diffs":[[1,"        mag = Math.pow(mag, sportMode ? 0.9 : 1.05)\n"]]},{"start1":2786,"length1":51,"diffs":[[1,"        if (forwardRaw < 0) {\n            // forward remains positive\n            baseSpeed = baseSpeed\n        } else {\n            // backward negative\n            baseSpeed = -baseSpeed\n        }\n    } else {\n        baseSpeed = 0\n"]]},{"start1":3027,"length1":29,"diffs":[[1,"    // steering\n    let speedFrac = Math.min(Math.abs(baseSpeed) / MAX_SPEED, 1)\n    let reduction = Math.pow(1 - speedFrac, 0.7)\n\n"]]},{"start1":3240,"length1":0,"diffs":[[1,"        // immediate stop\n"]]},{"start1":3372,"length1":35,"diffs":[[1,"        let turnEffect = Math.trunc(TURN_BASE * (0.6 + 0.4 * reduction))\n"]]},{"start1":3724,"length1":118,"diffs":[[1,"    // clamp + smoothing\n    leftTarget = clamp(Math.trunc(leftTarget), -MAX_SPEED, MAX_SPEED)\n    rightTarget = clamp(Math.trunc(rightTarget), -MAX_SPEED, MAX_SPEED)\n"]]},{"start1":3892,"length1":0,"diffs":[[1,"    leftTarget = rateLimit(prevLeft, leftTarget, RATE_LIMIT)\n    rightTarget = rateLimit(prevRight, rightTarget, RATE_LIMIT)\n\n    leftTarget = Math.idiv(prevLeft * (SMOOTH_FACTOR - 1) + leftTarget, SMOOTH_FACTOR)\n    rightTarget = Math.idiv(prevRight * (SMOOTH_FACTOR - 1) + rightTarget, SMOOTH_FACTOR)\n\n"]]},{"start1":4251,"length1":32,"diffs":[[1,"    // send as plain CSV (seq,left,right)\n"]]}]}]},{"timestamp":1759767630539,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":70,"length1":0,"diffs":[[1,"\n"]]},{"start1":187,"length1":45,"diffs":[[1,""]]},{"start1":2074,"length1":217,"diffs":[[1,"    leftTarget = clamp(leftTarget, -MAX_SPEED, MAX_SPEED)\n    rightTarget = clamp(rightTarget, -MAX_SPEED, MAX_SPEED)\n"]]}]}]},{"timestamp":1759767761684,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]}]},{"timestamp":1759799049961,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":332,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1759765470079,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"sender\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1759767368946,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// Sender: tilt-to-drive controller (no LEDs/visual feedback)\nradio.setGroup(7)\n\n// CONFIG\nconst LOOP_MS = 25\nconst RADIO_GROUP = 7\n\nconst MAX_RAW = 1000\nconst MAX_SPEED_NORMAL = 230\nconst MAX_SPEED_SPORT = 255\nconst DEADZONE = 30\nconst TURN_BASE = 250\n\nconst SMOOTH_FACTOR_NORMAL = 3\nconst SMOOTH_FACTOR_SPORT = 2\nconst RATE_LIMIT_NORMAL = 80\nconst RATE_LIMIT_SPORT = 160\n\nconst CALIBRATE_HOLD_MS = 1200\nconst SPORT_TOGGLE_HOLD_MS = 1200\n\n// STATE\nlet neutralY = input.acceleration(Dimension.Y)\nlet sportMode = false\nlet prevLeft = 0\nlet prevRight = 0\nlet seq = 0\n\nlet aWasDown = false\nlet bWasDown = false\nlet aDownStart = 0\nlet bDownStart = 0\nlet abCalibratedFlag = false\nlet bToggleFlag = false\n\nradio.setGroup(RADIO_GROUP)\n\nfunction clamp(v: number, lo: number, hi: number): number {\n    if (v < lo) return lo\n    if (v > hi) return hi\n    return v\n}\n\nfunction rateLimit(prev: number, target: number, maxDelta: number): number {\n    let delta = target - prev\n    if (delta > maxDelta) delta = maxDelta\n    if (delta < -maxDelta) delta = -maxDelta\n    return prev + delta\n}\n\nbasic.forever(function () {\n    let now = input.runningTime()\n    let a = input.buttonIsPressed(Button.A)\n    let b = input.buttonIsPressed(Button.B)\n\n    // A+B long press -> calibrate neutral (non-visual)\n    if (a && b) {\n        if (!(aWasDown && bWasDown)) {\n            // start of simultaneous press\n            aDownStart = now\n            bDownStart = now\n            abCalibratedFlag = false\n        } else {\n            if (!abCalibratedFlag && now - aDownStart >= CALIBRATE_HOLD_MS) {\n                neutralY = input.acceleration(Dimension.Y)\n                abCalibratedFlag = true\n            }\n        }\n    }\n\n    // B long press -> toggle sport mode (non-visual)\n    if (b && !a) {\n        if (!bWasDown) {\n            bDownStart = now\n            bToggleFlag = false\n        } else {\n            if (!bToggleFlag && now - bDownStart >= SPORT_TOGGLE_HOLD_MS) {\n                sportMode = !sportMode\n                bToggleFlag = true\n            }\n        }\n    }\n\n    // update last button states\n    aWasDown = a\n    bWasDown = b\n\n    // read and center tilt\n    let rawY = input.acceleration(Dimension.Y) - neutralY\n    let forwardRaw = -rawY\n\n    // mode params\n    let MAX_SPEED = sportMode ? MAX_SPEED_SPORT : MAX_SPEED_NORMAL\n    let SMOOTH_FACTOR = sportMode ? SMOOTH_FACTOR_SPORT : SMOOTH_FACTOR_NORMAL\n    let RATE_LIMIT = sportMode ? RATE_LIMIT_SPORT : RATE_LIMIT_NORMAL\n\n    // compute base speed\n    let baseSpeed = 0\n    let absRaw = Math.abs(forwardRaw)\n    if (absRaw > DEADZONE) {\n        let mag = (absRaw - DEADZONE) / (MAX_RAW - DEADZONE)\n        if (mag > 1) mag = 1\n        mag = Math.pow(mag, sportMode ? 0.9 : 1.05)\n        baseSpeed = Math.trunc(mag * MAX_SPEED)\n        if (forwardRaw < 0) {\n            // forward remains positive\n            baseSpeed = baseSpeed\n        } else {\n            // backward negative\n            baseSpeed = -baseSpeed\n        }\n    } else {\n        baseSpeed = 0\n    }\n\n    // steering\n    let speedFrac = Math.min(Math.abs(baseSpeed) / MAX_SPEED, 1)\n    let reduction = Math.pow(1 - speedFrac, 0.7)\n\n    let leftTarget = baseSpeed\n    let rightTarget = baseSpeed\n\n    if (a && b) {\n        // immediate stop\n        leftTarget = 0\n        rightTarget = 0\n    } else if (a || b) {\n        let turnSign = a ? -1 : 1\n        let turnEffect = Math.trunc(TURN_BASE * (0.6 + 0.4 * reduction))\n        if (baseSpeed != 0) {\n            leftTarget = baseSpeed - turnSign * turnEffect\n            rightTarget = baseSpeed + turnSign * turnEffect\n        } else {\n            leftTarget = -turnSign * turnEffect\n            rightTarget = turnSign * turnEffect\n        }\n    }\n\n    // clamp + smoothing\n    leftTarget = clamp(Math.trunc(leftTarget), -MAX_SPEED, MAX_SPEED)\n    rightTarget = clamp(Math.trunc(rightTarget), -MAX_SPEED, MAX_SPEED)\n\n    leftTarget = rateLimit(prevLeft, leftTarget, RATE_LIMIT)\n    rightTarget = rateLimit(prevRight, rightTarget, RATE_LIMIT)\n\n    leftTarget = Math.idiv(prevLeft * (SMOOTH_FACTOR - 1) + leftTarget, SMOOTH_FACTOR)\n    rightTarget = Math.idiv(prevRight * (SMOOTH_FACTOR - 1) + rightTarget, SMOOTH_FACTOR)\n\n    prevLeft = leftTarget\n    prevRight = rightTarget\n\n    // send as plain CSV (seq,left,right)\n    seq = (seq + 1) & 65535\n    radio.sendString(\"\" + seq + \",\" + leftTarget + \",\" + rightTarget)\n\n    basic.pause(LOOP_MS)\n})\n","README.md":"","pxt.json":"{\n    \"name\": \"sender\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-rekabit\": \"github:cytrontechnologies/pxt-rekabit#v1.2.3\",\n        \"radio-broadcast\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1759799049961,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"radio.setGroup(7)\n\n// CONFIG\nconst LOOP_MS = 25\nconst RADIO_GROUP = 7\nconst MAX_RAW = 1000\nconst MAX_SPEED = 255\nconst DEADZONE = 30\nconst TURN_BASE = 250\nconst CALIBRATE_HOLD_MS = 1200\nconst SMOOTH_FACTOR = 4  // subtle smoothing\n\n// STATE\nlet neutralY = input.acceleration(Dimension.Y)\nlet prevLeft = 0\nlet prevRight = 0\nlet seq = 0\n\nlet aWasDown = false\nlet bWasDown = false\nlet aDownStart = 0\nlet bDownStart = 0\nlet abCalibratedFlag = false\n\nradio.setGroup(RADIO_GROUP)\n\nfunction clamp(v: number, lo: number, hi: number): number {\n    if (v < lo) return lo\n    if (v > hi) return hi\n    return v\n}\n\nbasic.forever(function () {\n    let now = input.runningTime()\n    let a = input.buttonIsPressed(Button.A)\n    let b = input.buttonIsPressed(Button.B)\n\n    // A+B long press -> calibrate neutral\n    if (a && b) {\n        if (!(aWasDown && bWasDown)) {\n            aDownStart = now\n            bDownStart = now\n            abCalibratedFlag = false\n        } else if (!abCalibratedFlag && now - aDownStart >= CALIBRATE_HOLD_MS) {\n            neutralY = input.acceleration(Dimension.Y)\n            abCalibratedFlag = true\n        }\n    }\n\n    aWasDown = a\n    bWasDown = b\n\n    // read tilt\n    let rawY = input.acceleration(Dimension.Y) - neutralY\n    let forwardRaw = -rawY\n\n    // compute base speed\n    let baseSpeed = 0\n    let absRaw = Math.abs(forwardRaw)\n    if (absRaw > DEADZONE) {\n        let mag = (absRaw - DEADZONE) / (MAX_RAW - DEADZONE)\n        if (mag > 1) mag = 1\n        baseSpeed = Math.trunc(mag * MAX_SPEED)\n        if (forwardRaw > 0) baseSpeed = -baseSpeed\n    }\n\n    // steering with buttons\n    let leftTarget = baseSpeed\n    let rightTarget = baseSpeed\n\n    if (a && b) {\n        leftTarget = 0\n        rightTarget = 0\n    } else if (a || b) {\n        let turnSign = a ? -1 : 1\n        let turnEffect = TURN_BASE\n        if (baseSpeed != 0) {\n            leftTarget = baseSpeed - turnSign * turnEffect\n            rightTarget = baseSpeed + turnSign * turnEffect\n        } else {\n            leftTarget = -turnSign * turnEffect\n            rightTarget = turnSign * turnEffect\n        }\n    }\n\n    // subtle smoothing to prevent jerk\n    leftTarget = Math.idiv(prevLeft * (SMOOTH_FACTOR - 1) + leftTarget, SMOOTH_FACTOR)\n    rightTarget = Math.idiv(prevRight * (SMOOTH_FACTOR - 1) + rightTarget, SMOOTH_FACTOR)\n\n    prevLeft = leftTarget\n    prevRight = rightTarget\n\n    // send CSV: seq,left,right\n    seq = (seq + 1) & 65535\n    radio.sendString(\"\" + seq + \",\" + leftTarget + \",\" + rightTarget)\n\n    basic.pause(LOOP_MS)\n})\n","README.md":"","pxt.json":"{\n    \"name\": \"sender\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-rekabit\": \"github:cytrontechnologies/pxt-rekabit#v1.2.3\",\n        \"radio-broadcast\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1759799049989}